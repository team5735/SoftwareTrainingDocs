# Git and GitHub: Your Time Machine for Code

This is meant to go along with the git slides you can find in the team Google Drive folder, assuming I've done my job.

The goal of this presentation is giving you a primer so that when you hear these terms again you aren't completely lost and hopefully even remember what they mean.

## The purpose of version control

* History
* Undo safety
* Collaboration
* Structure
* Stability

----------

Essentially, version control is a way of keeping track of a history of changes. Think of it as an advanced, professional version of Version History in Google Docs, but upgraded to multiple timelines and much nerdier.

## Definitions

* The code: a bunch of java-language files
* Git repository: a directory (folder) containing the code and a .git directory that is used by git to manage the history of the repository (the existence of .git makes it a repository)
* Example repository structure for FRC
    - .git
        - Handles internals for git
    - src/main/java/frc/robot
        - RobotContainer.java
        - subsystems/
        - ...
* Clone: a local copy of a git repository (here, that’s either on your school laptops or on the team laptops)
* Remote: the "master copy" of a repository. It's the version that GitHub hosts. Syncing between computers involves communicating with the remote.
* Commit: a specific version of the repository, represented as a set of changes to the previous version
* The working tree: the technical name for the code. It’s basically everything not in .git
* The staging area: a list of files that git will make a commit for when you tell it to (with git commit). This can be used to not commit all of the changes you’ve made at once
* HEAD: another way to say 'the commit that represents the files actively in the repository that you can edit'
* The stash: essentially a temporary commit that lets you undo a lot of changes safely, set them aside, and then redo them later

## A typical git project structure

The slide shows a circle for the remote with multiple 'clones' pointing to the circle. The arrows represent that the clones are connected to the remote and know how to interact with it. They're one-way because the remote never forces changes onto the clones, but the clones force changes and request information from the remote.

### Quickly being petty

GitHub and Git aren't the same thing. GitHub hosts the repositories using the git software. git is the software that manages the version control, communicates between clones and remotes, and generally does the actual version control work.

## Git history

### A simple linear history

```
A <── B <── C <── D <── E <── F
```

Each letter is a commit. They represent a snapshot in time, manually captured, and stored as a set of changes to the previous commit. For example, B might add a line, C might replace that line with another, and D might delete the file the previous two commits modified entirely.

In this diagram, F can be assumed to be HEAD, representing the files that you're currently working on.

The programmer made changes and committed - essentially saved - those changes sequentially. This is the simplest type of timeline (linear).

We can go back in time to a specific snapshot, again like Google Docs' version control (but you need to make manual snapshots) with the power of `git checkout`.

### One developer using git

Let's paint a picture of one developer using git to keep track of their project over time in perfect solitude. You don't even need a host like GitHub for this (for now)- due to everything that's present in a repository, git doesn't even need a remote to operate, nor does it need one single remote, but more complex things with remotes are out of scope for this course.

(Fun fact: remotes are actually just normal repositories, often with their working trees disabled, because nobody at GitHub is going to be working on our code, so they don't need to see it; all the need is the commit history.)

Our lone developer starts with one commit called A, termed the initial commit because it's the first ever in our beautiful repository. Let's represent her history as such:

```
A
```

Simple enough. Imagine that this commit represents a template FRC project, including for example RobotContainer.java, a few example Commands, Subsystems, and so on.

Ok, now she'd like to add a simple motor subsystem. She writes this code:

```java
// ... skip imports ...
public class MotorSubsystem extends Subsystem {
    private final CANSparkMax motor = new CANSparkMax(Constants.MOTOR_ID, MotorType.kBrushless);

    private void set(Voltage volts) {
        motor.setVoltage(volts.in(Volts));
    }

    public Command getSetVoltage(LinearVelocity volts) {
        return startEnd(() -> set(volts), () -> set(Volts.of(0)));
    }
}
```

... and then commits her changes, whether that be with the VSCode GUI or with git commands.

(The git commands would look like:
  - Stage all files: `git add .` (in the project root)
  - Commit staged files: `git commit -m "added MotorSubsystem"`
)

Now, the history looks like this:

```
A <── B
```

Did you spot the bug? If so, congrats. If you didn't, that's fine. VSCode would have yelled at you anyway (one of the advantages of the units library!). It seems our programmer got a bit confused between whether they're using voltages or speed- maybe she copied her homework from our motors lesson's example.

It's no problem though, she can fix it nice and simply:

```diff
diff --git a/MotorSubsystem.java b/MotorSubsystem.java
index 902c95a..59b99b3 100644
--- a/MotorSubsystem.java
+++ b/MotorSubsystem.java
@@ -6,7 +6,7 @@ public class MotorSubsystem extends Subsystem {
         motor.setVoltage(volts.in(Volts));
     }
 
-    public Command getSetVoltage(LinearVelocity volts) {
+    public Command getSetVoltage(Voltage volts) {
         return startEnd(() -> set(volts), () -> set(Volts.of(0)));
     }
 }
```

... what was that?

That's a diff! It's how git commits are stored internally and it represents a change between two files. It's actually its own file type - called unified diff - but you don't really need to worry about those details.

Alright, so now she's made those changes to the files themselves. Now to commit them. She can use the same process as last time, but with a different commit message- maybe 'correct unit error in MotorSubsystem'.

And that's the story of how she came by three commits. Her history now looks like this:

```
A <── B <── C
```

I'll skip over the next couple commits, just assume that she wrote code and committed just like that three more times, making commits D, E, and F.

### `git checkout`: go back in time (and more)

`git checkout` is a command that can do a lot, but for a linear history like this its main purpose is to go back in time. When you check out a commit, you move your HEAD to point to that commit. (This is referred to as a 'detatched HEAD' because HEAD's commit isn't named anything other than its commit hash.)

This has a couple implications, but the most important is that it overwrites the files in the working tree (aka the files that you're writing code in). The main purpose of this is of course to look back at that point in time.

You should know that git is really, really picky about *never* losing data. This means that git will pretty much always warn you when you're about to do something irreversible, unless you explicitly tell it not to (typically with something like --force).

Anyway, when I said that it overwrites the working tree, I left out that it first checks to see that it's clean, which is another way of saying that it's identical to what HEAD was before you tried to check out a different commit.

Furthermore, this means that if we're keeping things simple - and we are, because teaching this doesn't make sense until branches - you really shouldn't make any changes while in a detatched HEAD state. Just use it to look around.

#### Actually using `git checkout`

Ok, with all that aside, how do you actually checkout something? It's complicated, but it's not *that* bad. I'll go over VSCode checkouts first before I explain the command line.

In VSCode, when you open the git toolbar (again, the third icon on the left), you should see by default the project history on the bottom. To check something out, right-click on a specific commit and choose 'Checkout (detatched)'. To go back to the main branch, you can press the hexadecimal string (which is a fancy way of saying 'those 8 letters and numbers') in the bottom left of the window and click on the branch called main.

For my terminal enjoyers, the commands are simple enough. First, you need to get a view of the history, akin to what VSCode shows graphically. The base command for this is `git log`, but it gives too much information by default, so I prefer `git log --oneline` because it's just easier to read. When you run `git log --oneline`, you may not get your terminal prompt back immediately, and instead your cursor resides after a : character. This is a 'pager', which git uses when there's too much to show in one screenful. You can scroll through the output with the arrow keys, or scrolling, sometimes, sort of.

## Pushing and remotes

What I've just described is an incomplete picture. (This will be a recurring theme). In this picture of linear history, you only see one history, because we're only considering the simple case of one copy of the repository. However, in our team, we actually use two copies. If you remember from earlier, you might have already realized what GitHub does: it just stores a second copy of our repositories.

But how do we sync the two copies? After all, we can't really work on the same code if we have different copies of the code. Well, for this purpose, commands like `git push` and `git pull` (and `git fetch`) exist. An easy way to remember which is which (with one developer and a linear history) is that you push your changes at other people, and then receive them by pulling them towards themselves. Alternatively, if you use the wrong command, nothing happens, so you can just figure it out.

Ok, perhaps this would benefit from an example.

We have this history locally from our above saga:

```
A <── B <── C <── D <── E <── F
```

And this is the history in the remote's copy (remember that the remote has a full copy of everything in the project's history, which is considered the authoritative copy):

```
A <── B <── C <── D
```

Now, our thoroughly trialled developer from earlier would like to push her new changes to the remote. In other words, she'd like commits E and F to appear in their same place on the remote's repository without much fuss.
