# Git and GitHub: Your Time Machine for Code

This is meant to go along with the git slides you can find in the team Google Drive folder, assuming I've done my job.

The goal of this presentation is giving you a primer so that when you hear these terms again you aren't completely lost and hopefully even remember what they mean.

## The purpose of version control

* History
* Undo safety
* Collaboration
* Structure
* Stability

Essentially, version control is a way of keeping track of a history of changes. Think of it as an advanced, professional version of Version History in Google Docs, but upgraded to multiple timelines and much nerdier.

## Definitions

* The code: a bunch of java-language files (in our case)
* Git repository: a directory (folder) containing the code and a .git directory that is used by git to manage the history of the repository (the existence of .git makes it a repository)
* Example repository structure for FRC
    - .git
        - Handles internals for git
    - src/main/java/frc/robot
        - RobotContainer.java
        - subsystems/
        - ...
* Clone: a local copy of a git repository (here, that’s either on your school laptops or on the team laptops)
* Remote: the "master copy" of a repository. It's the version that GitHub hosts. Syncing between computers involves communicating with the remote.
* Commit: a specific version of the repository, represented as a set of changes to the previous version
* The working tree: the technical name for the code. It’s basically everything not in .git
* The staging area: a list of files that git will make a commit for when you tell it to (with git commit). This can be used to not commit all of the changes you’ve made at once
* HEAD: another way to say 'the commit that represents the files actively in the repository that you can edit'
* The stash: essentially a temporary commit that lets you undo a lot of changes safely, set them aside, and then redo them later

## A typical git project structure

The slide shows a circle for the remote with multiple 'clones' pointing to the circle. The arrows represent that the clones are connected to the remote and know how to interact with it. They're one-way because the remote never forces changes onto the clones, but the clones force changes and request information from the remote.

### Quickly being petty

GitHub and Git aren't the same thing. GitHub hosts the repositories using the git software. git is the software that manages the version control, communicates between clones and remotes, and generally does the actual version control work.

## Git history

### A simple linear history

```
A <── B <── C <── D <── E <── F
```

Each letter is a commit. They represent a snapshot in time, manually captured, and stored as a set of changes to the previous commit. For example, B might add a line, C might replace that line with another, and D might delete the file the previous two commits modified entirely.

In this diagram, F can be assumed to be HEAD, representing the files that you're currently working on.

The programmer made changes and committed - essentially saved - those changes sequentially. This is the simplest type of timeline (linear).

We can go back in time to a specific snapshot, again like Google Docs' version control (but you need to make manual snapshots) with the power of `git checkout`.

### One developer using git

Let's paint a picture of one developer using git to keep track of their project over time in perfect solitude. You don't even need a host like GitHub for this (for now)- due to everything that's present in a repository, git doesn't even need a remote to operate, nor does it need one single remote, but more complex things with remotes are out of scope for this course.

(Fun fact: remotes are actually just normal repositories, often with their working trees disabled, because nobody at GitHub is going to be working on our code, so they don't need to see it; all the need is the commit history.)

Our lone developer starts with one commit called A, termed the initial commit because it's the first ever in our beautiful repository. Let's represent her history as such:

```
A
```

Simple enough. Imagine that this commit represents a template FRC project, including for example RobotContainer.java, a few example Commands, Subsystems, and so on.

Ok, now she'd like to add a simple motor subsystem. She writes this code:

```java
// ... skip imports ...
public class MotorSubsystem extends Subsystem {
    private final CANSparkMax motor = new CANSparkMax(Constants.MOTOR_ID, MotorType.kBrushless);

    private void set(Voltage volts) {
        motor.setVoltage(volts.in(Volts));
    }

    public Command getSetVoltage(LinearVelocity volts) {
        return startEnd(() -> set(volts), () -> set(Volts.of(0)));
    }
}
```

... and then commits her changes, whether that be with the VSCode GUI or with git commands.

(The git commands would look like:
  - Stage all files: `git add .` (in the project root)
  - Commit staged files: `git commit -m "added MotorSubsystem"`
)

Now, the history looks like this:

```
A <── B
```

Did you spot the bug? If so, congrats. If you didn't, that's fine. VSCode would have yelled at you anyway (one of the advantages of the units library!). It seems our programmer got a bit confused between whether they're using voltages or speed- maybe she copied her homework from our motors lesson's example.

It's no problem though, she can fix it nice and simply:

```diff
diff --git a/MotorSubsystem.java b/MotorSubsystem.java
index 902c95a..59b99b3 100644
--- a/MotorSubsystem.java
+++ b/MotorSubsystem.java
@@ -6,7 +6,7 @@ public class MotorSubsystem extends Subsystem {
         motor.setVoltage(volts.in(Volts));
     }
 
-    public Command getSetVoltage(LinearVelocity volts) {
+    public Command getSetVoltage(Voltage volts) {
         return startEnd(() -> set(volts), () -> set(Volts.of(0)));
     }
 }
```

... what was that?

That's a diff! It's how git commits are stored internally and it represents a change between two files. It's actually its own file type - called unified diff - but you don't really need to worry about those details.

Alright, so now she's made those changes to the files themselves. Now to commit them. She can use the same process as last time, but with a different commit message- maybe 'correct unit error in MotorSubsystem'.

And that's the story of how she came by three commits. Her history now looks like this:

```
A <── B <── C
```

I'll skip over the next couple commits, just assume that she wrote code and committed just like that three more times, making commits D, E, and F.

### `git checkout`: go back in time (and more)

`git checkout` is a command that can do a lot, but for a linear history like this its main purpose is to go back in time. When you check out a commit, you move your HEAD to point to that commit. (This is referred to as a 'detatched HEAD' because HEAD's commit isn't named anything other than its commit hash.)

This has a couple implications, but the most important is that it overwrites the files in the working tree (aka the files that you're writing code in). The main purpose of this is of course to look back at that point in time.

You should know that git is really, really picky about *never* losing data. This means that git will pretty much always warn you when you're about to do something irreversible, unless you explicitly tell it not to (typically with something like --force).

Anyway, when I said that it overwrites the working tree, I left out that it first checks to see that it's clean, which is another way of saying that it's identical to what HEAD was before you tried to check out a different commit.

Furthermore, this means that if we're keeping things simple - and we are, because teaching this doesn't make sense until branches - you really shouldn't make any changes while in a detatched HEAD state. Just use it to look around.

#### Actually using `git checkout`

Ok, with all that aside, how do you actually checkout something? It's complicated, but it's not *that* bad. I'll go over VSCode checkouts first before I explain the command line.

In VSCode, when you open the git toolbar (again, the third icon on the left), you should see by default the project history on the bottom. To check something out, right-click on a specific commit and choose 'Checkout (detatched)'. To go back to the main branch, you can press the hexadecimal string (which is a fancy way of saying 'those 8 letters and numbers') in the bottom left of the window and click on the branch called main.

For my terminal enjoyers, the commands are simple enough. First, you need to get a view of the history, akin to what VSCode shows graphically. The base command for this is `git log`, but it gives too much information by default, so I prefer `git log --oneline` because it's just easier to read. When you run `git log --oneline`, you may not get your terminal prompt back immediately, and instead your cursor resides after a : character. This is a 'pager', which git uses when there's too much to show in one screenful. You can scroll through the output with the arrow keys, or scrolling, sometimes, sort of.

## Pushing and remotes

What I've just described is an incomplete picture. (This will be a recurring theme). In this picture of linear history, you only see one history, because we're only considering the simple case of one copy of the repository. However, in our team, we actually use two copies. If you remember from earlier, you might have already realized what GitHub does: it just stores a second copy of our repositories.

But how do we sync the two copies? After all, we can't really work on the same code if we have different copies of the code. Well, for this purpose, commands like `git push` and `git pull` (and `git fetch`) exist. An easy way to remember which is which (with one developer and a linear history) is that you push your changes at other people, and then receive them by pulling them towards themselves. Alternatively, if you use the wrong command, nothing happens, so you can just figure it out.

Ok, perhaps this would benefit from an example.

We have this history locally from our above saga:

```
A <── B <── C <── D <── E <── F
```

And this is the history in the remote's copy (remember that the remote has a full copy of everything in the project's history, which is considered the authoritative copy):

```
A <── B <── C <── D
```

Now, our thoroughly trialled developer from earlier would like to push her new changes to the remote. In other words, she'd like commits E and F to appear in their same place on the remote's repository without much fuss. The command for this is simple, assuming everything's been set up (which it should be, after our setup lesson): `git push`.

Ok, assuming we can actually trust that the history is linear and simple like it is here (we'll cover the case where it isn't later), that should be it. The remote's history now looks like:

```
A <── B <── C <── D <── E <── F
```

Mission accomplished.

## Divergent Histories

This is where it gets complicated. Everything before this point was quite straightforward (pun intended), but it stops being so when we have consider more than one developer contributing to the same remote, so let's do so.

Let's say everything goes kosher like this:

```
remote:
A <── B
developer 1 (she/her):
A
developer 2 (he/him):
A <── B
```

We have one well-behaved developer who's made commit B and pushed it to the remote. Now the other developer hasn't pulled his commit from the remote, and so on her repository she probably doesn't have any files (the initial commit is empty, after all) and her history only has commit A in it, as you can see. The remedy for this is simple: `git pull` will grab B from the remote and add it to developer 1's repository (diligently making the requisite changes to the affected files):

```
remote:
A <── B
developer 1 (she/her):
A <── B
developer 2 (he/him):
A <── B
```

Now, developer 2 will make two new commits, C and D, and push them as they're made. We end up with this:

```
remote:
A <── B <── C <── D
developer 1 (she/her):
A <── B <── C <── D
developer 2 (he/him):
A <── B
```

However, developer 2 is rather less disciplined and forgot to `git pull` before making his changes and trying to commit them. As a result, we now have a commit named E (reminder that that stands for a long hash) (E is unique even if it has the same contents as, say, D, because its parent is different), and when developer 2 tries to `git push`, he'll get an error, as his HEAD (the most recent commit) isn't the same as the remote's HEAD.

(
Here's the history:
```
remote:
A <── B <── C <── D
developer 1 (she/her):
A <── B <── C <── D
developer 2 (he/him):
A <── B <── E
```
)

What's the solution? Well, we need to undo the commit, pull the changes, and redo the commit again. This can be done either explicitly or automatically, and I'll show the longer explicit path first as it teaches other important commands:

1. `git reset @^`
    - This command instructs `git` to essentially undo the most recent commit, also unstaging the files. 
> [!NOTE]
> The commit technically still exists, it's just that nothing else in the repository mentions it, so it's unreachable. These commits will stay in the repository indefinitely until you run `git gc`.
    - Now, the changes developer 2 made to his repository are preserved, but you can't pull with uncommitted changes (as they'd be overwritten), so you have to do something with them:
2. `git stash`
    - This command takes the changes just uncommitted and essentially makes a temporary commit of them in a special place called the 'stash'. It also undoes the current changes to the working tree (whether or not they're staged).
3. `git pull`
    - Now that developer 2 has temporarily sentenced E to the shadow realm, they can pull commits C and D.
4. `git stash pop`
    - This re-applies the changes saved in the stash to the working tree
5. recommit
    - Unfortunately, this process loses the commit information (there are other methods that preserve such information, such as the shortened one below!), so you have to write the commit message again. In the terminal, this is written as `git add .` (assuming you're in the root directory of the project) and `git commit -m "..."` (put your message in quotes)

That was complicated, and developer 2 (as we've already seen) is rather lazy. Could he do this in a better way? Of course! It would not be a lecture without sufficient preaching of impractical and unintuitive solutions.

Honestly, though, I just wanted to show you `git stash` as a way of preserving any WIP contents of your working tree for later, whenever and wherever that may be. Also, stashes are not pushed, ever, so it doesn't matter what sort of garbage you put in there, it will never leave your computer.

Now for the actual practical command to use in that situation: `git pull --rebase`. That's it. That's- that's the entire process. What this does is something called a 'rebase', which is essentially the short form of what we did above with the added benefit of preserving the commit message. It's a small part of a very large command called `git rebase`, which can do so many things, but can be summarized as 'temporarily undo some commits and reapply them, potentially with changes' (in this case, the changes are nothing more than inserting the new commits from the remote).

Ok, now our histories look like this:
```
remote:
A <── B <── C <── D
developer 1 (she/her):
A <── B <── C <── D
developer 2 (he/him):
A <── B <── C <── D
```

# The Branches Part

It gets complicated from here on out. Hopefully you got at least some of what came before; if not, feel free to peruse this lesson in your free time. The alternative is simply asking experienced software members more questions :)

I'd like to say also that we don't expect you to understand, much less use, most of this lesson, especially on your first day. It's meant to whet your appetite, and more importantly to serve as a reference to divert some portion of requests to preserve the all-important software team bandwidth (which is not actually that important).

### First, more definitions

* Diverging histories: two different 'versions' of the codebase that have a common ancestor commit
* Merging: making a commit that reconciles changesets from two (or rarely more) divergent histories
* Merge commit: a commit that incorporates the changes from its divergent history parents, possibly including its own changes on top of those
* Branch: a name for a specific version/history of the project (multiple branches typically diverge and can therefore be merged). Represented as a specific commit, branches can also be a previous commit in a linear past, assuming no divergence occurs

## Divergent histories

If you didn't get the definition at first glance, here's an example:

```
          ┌─ C <── F
A <── B <─┤         
          └─ D <── E
```

In the above repository history, there are *two* commits that claim B as their parent: C and D. I'm going to gloss over how this is accomplished for now, but it suffices to say for now that the above construct can exist within a single repository and that, furthermore, it's very normal. You can see how these two diverging histories gained the moniker of 'branches', as they look like branches in a tree. But these branches have names! Let's be imaginative and call them `main` and `dev` (possibly the two most common branches you'll see here in FRC programming). I'll name them like this:

```
          ┌─ C <── F (HEAD, main)
A <── B <─┤         
          └─ D <── E (dev)
```

Note how HEAD is on the same commit as main. From that you can correctly infer that the repository's files are represented by commit F. This also means that if you just commit from here, you'll make a commit that has F as its parent and furthers the main branch (branch names follow you by default).

### Oh yea, branches

I suppose that a quick note about branches and branch names is in order. One of the most important things for understanding everything about branches in git is that branches aren't really anything other than a commit name. In our above example, commit F is what `main` 'points' to and E is what `dev` 'points' to. All the history is determined whenever you ask for it, by going to each commit and then following its parent.

Also, given that each branch uniquely names one commit in particular, that branch name is pretty much always available as an alias for that commit.

Furthering a branch is a simple affair: the commit is created, its parent commit is written, and then the branch you're currently on is updated to point to that new commit.

If you think about it, this simplicity implies that branches don't need to diverge, because I didn't say anything about that, which is in fact the case. Given the following linear history, you can `git switch` to either of `main` or `dev` and it will just work, taking you back or forward in time (assuming you're nowhere else).

```
A <── B <── C <── D <── E <── F
      ^ (HEAD, main)          ^ (dev)
```

## Merging two branches

This is one of the most important things - and most common - things you can do with two branches. Merging two (divergent) commits (commonly denoted by branches) effectively tries to make a commit that represents both sets of changes at the same time. A diagram is very helpful here:

```
          ┌─ D (HEAD, main)
A <── B <─┤
          └─ C <── E <── F <── G <── H (dev)
```

Here, our developer is on the main branch, as can be seen by the HEAD marker, and wishes to 'merge in' the changes made to the development branch so far. This is a very, very common scenario in our robot code, as our `dev` branch is where development occurs (hence the name), and is thus 'unstable' (rapidly changing and therefore may or may not work). On the other hand, `main` changes very infrequently, and is intended to always be essentially the 'most recent working version of our code'. But, when we've made and tested changes to `dev`, we'd like to move those down into `main`, as we've just verified that the codebase at `dev` (H in the above diagram) is ready for competition.

The command for this is simple, assuming you're on the `main` branch: `git merge dev`. Most of the time this is a very simple operation, as there aren't often many code changes made on the `main` branch, due to its nature. In the case of a linear history, for example two diagrams ago where there is a linear hisory with `main` and `dev` marking out points in time, `git merge dev` just moves `main` to be at `dev`. This is called a 'fast-forward' and in that case would end up with this situation:

```
A <── B <── C <── D <── E (HEAD, main, dev)
```

However, in our actual example at the start of this section, somebody has made a change on that branch (commit D), likely something like changing one number during the competition, or some other similar hotfix. In this case, you'll end up with a new commit being made, and the following will be the resultant structure:

```
          ┌─ D <─────────────────────────┐
A <── B <─┤                              ├─ I (HEAD, main)
          └─ C <── E <── F <── G <── H <─┘
                                     ^ (dev)
```

There's a few important things to note here. First of all, seeing how commit I now has every other commit in the repository somewhere in its ancestry, it represents the sum of all their changes, along with whatever may be included in I (remember, it includes a normal commit, sort of).

Second and arguably more important, `dev` has not moved. That means that if you `git switch dev`, your repository will not include those changes made in commits D or I. And if you make a commit on `dev`, **it will create a divergent history**. This is probably the only unintuitive thing about git commands, assuming you think about histories in the right manner, as I've tried to teach.

So now we've successfully merged `dev` into `main`. Now, from the perspective of the `main` branch, `dev` is considered 'merged': all its changes are visible in the state of the repository that `main` represents. Therefore, we can (and should, if its task is complete) delete it: `git branch -d dev`. Alternatively, if we would like to continue working on `dev` starting at where `main` is now, we should `git switch` to `dev` and `git merge main`. As you can see, because `dev` is a direct ancestor of `main`, merging can be completed simply by moving `dev` up to `main`. This is called a 'fast-forward', if you recall.

---

Congratulations. You've made it to the end of the git lesson. Quickly, a few conventions.

## Our team structure

In our team, as has been discussed, we prefer to have our 'competition' branch be `main`. This is the default branch. It's intended to be a version of the robot code that always works: it's run at competitions, at demos, and so on. Essentially, if we want the robot to work *now*, we `git switch main` (and redeploy!). Our development branch is `dev`. During the later stages of the build season as well as the preseason, when the code is relatively inactive, we just commit straight to `dev`, so as to avoid having to deal with multiple branches, though longer-term projects will make their own branch. We also like to make commits that all developers should see during build season to `dev`.

However, during build season, we use something more specific: topic branches. These are a multitude of more specific branches, e.g. 'drivetrain', 'limelight', 'elevator', and so on. It's not required that there be one for each subsystem, but it helps with prototyping, because if you have a branch (version of the codebase) that only has, say, elevator code, you can quickly switch to that and not be bothered (ideally speaking) by other code and/or button bindings. During mechanical integration time, we do the analogous thing in software: endless merging into `dev` and eventually `main`.

Hotfixes during competition are just made. Don't worry about git and just make the change if somebody asks you to. It will (ideally!) eventually be committed to `main`, and then when we have more time we can deal with its reprocussions on `dev` later.
