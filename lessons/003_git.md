# Git and GitHub: Your Time Machine for Code

This is meant to go along with the git slides you can find in the team Google Drive folder, assuming I've done my job.

The goal of this presentation is giving you a primer so that when you hear these terms again you aren't completely lost and hopefully even remember what they mean.

## The purpose of version control

* History
* Undo safety
* Collaboration
* Structure
* Stability

----------

Essentially, version control is a way of keeping track of a history of changes. Think of it as an advanced, professional version of Version History in Google Docs, but upgraded to multiple timelines and much nerdier.

## Definitions

* The code: a bunch of java-language files
* Git repository: a directory (folder) containing the code and a .git directory that is used by git to manage the history of the repository (the existence of .git makes it a repository)
* Example repository structure for FRC
    - .git
        - Handles internals for git
    - src/main/java/frc/robot
        - RobotContainer.java
        - subsystems/
        - ...
* Clone: a local copy of a git repository (here, that’s either on your school laptops or on the team laptops)
* Remote: the "master copy" of a repository. It's the version that GitHub hosts. Syncing between computers involves communicating with the remote.
* Commit: a specific version of the repository, represented as a set of changes to the previous version
* The working tree: the technical name for the code. It’s basically everything not in .git
* The staging area: a list of files that git will make a commit for when you tell it to (with git commit). This can be used to not commit all of the changes you’ve made at once
* HEAD: another way to say 'the commit that represents the files actively in the repository that you can edit'
* The stash: essentially a temporary commit that lets you undo a lot of changes safely, set them aside, and then redo them later

## A typical git project structure

The slide shows a circle for the remote with multiple 'clones' pointing to the circle. The arrows represent that the clones are connected to the remote and know how to interact with it. They're one-way because the remote never forces changes onto the clones, but the clones force changes and request information from the remote.

### Quickly being petty

GitHub and Git aren't the same thing. GitHub hosts the repositories using the git software. git is the software that manages the version control, communicates between clones and remotes, and generally does the actual version control work.

## Git history

### A simple linear history

```
A <── B <── C <── D <── E <── F
```

Each letter is a commit. They represent a snapshot in time, manually captured, and stored as a set of changes to the previous commit. For example, B might add a line, C might replace that line with another, and D might delete the file the previous two commits modified entirely.

In this diagram, F can be assumed to be HEAD, representing the files that you're currently working on.

The programmer made changes and committed - essentially saved - those changes sequentially. This is the simplest type of timeline (linear).

We can go back in time to a specific snapshot, again like Google Docs' version control (but you need to make manual snapshots) with the power of `git checkout`.

### One developer using git

Let's paint a picture of one developer using git to keep track of their project over time in perfect solitude. You don't even need a host like GitHub for this- due to what's present in a repository, git doesn't even need a remote to operate, nor does it need one single remote, but more complex things with remotes are out of scope for this course. (Fun fact: remotes are actually just normal repositories, often with their working trees disabled, because nobody at GitHub is going to be working on our code, so they don't need to see it; all the need is the commit history.)

We start with one commit A, called the initial commit because that's what it is:

```
A
```

Simple enough. Imagine that this commit represents a template FRC project, say it has RobotContainer.java, a few example Commands, Subsystems, and so on.

Ok, now our developer wants to add a simple motor subsystem. They write this code:

```java
// ... skip imports ...
public class MotorSubsystem extends Subsystem {
    private final CANSparkMax motor = new CANSparkMax(Constants.MOTOR_ID, MotorType.kBrushless);

    private void set(Voltage volts) {
        motor.setVoltage(volts.in(Volts));
    }

    public Command getSetVoltage(LinearVelocity volts) {
        return startEnd(() -> set(volts), () -> set(Volts.of(0)));
    }
}
```

... and then commit their changes, whether that be with the VSCode GUI or with git commands.

(The git commands would look like:
  - Stage all files: `git add .` (in the project root)
  - Commit staged files: `git commit -m "added MotorSubsystem"`
)

Now, the history looks like this:

```
A <── B
```

Did you spot the bug? If so, congrats; you're smarter than this (definitely fake) programmer, who didn't even see the error message. If you didn't, that's fine. It seems our programmer got a bit confused between whether they're using voltages or speed- maybe they copied their homework from our motors lesson's example.

It's no problem though, let's fix it:

```diff
diff --git a/MotorSubsystem.java b/MotorSubsystem.java
index 902c95a..59b99b3 100644
--- a/MotorSubsystem.java
+++ b/MotorSubsystem.java
@@ -6,7 +6,7 @@ public class MotorSubsystem extends Subsystem {
         motor.setVoltage(volts.in(Volts));
     }
 
-    public Command getSetVoltage(LinearVelocity volts) {
+    public Command getSetVoltage(Voltage volts) {
         return startEnd(() -> set(volts), () -> set(Volts.of(0)));
     }
 }
```

... what?

That's a diff! It's how git commits are stored internally and it represents a change between two files. It's actually its own file type - called unified diff - but you don't really need to worry about those details.

Alright, so you've made those changes. Now to commit them. You can use the same process as last time, but with a different commit message- maybe 'correct unit error in MotorSubsystem'.

And that's the story of how you came by three commits. It looks like this:

```
A <── B <── C
```

I'll skip over the next couple commits, just assume that we wrote code for commits D, E, and F.

### `git checkout`: 
